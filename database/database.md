### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
* 기본키(Primary key): 기본키는 관계형 데이터베이스에서 테이블의 모든 튜플을 고유하게 식별하는
속성 또는 속성 집합입니다. <br> 즉, 기본키를 사용하면 테이블의 모든 레코드를 중복없이 구별 할수있습니다.
  * 특징
    * **고유성(Uniqueness)**:기본키 값은 테이블 내에서 고유해야합니다. 즉, 동일한 값을 가진 두개 이상의 레코드가 존재해서는 안됩니다.
    * **NULL 값 제한**: 기본키는 NULL 값이 허용되지 않습니다. 이는 모든 레코드가 기본키값을 가져아 합니다.
    * **검색 및 조인에 용이**: 기본키는 테이블 간의 관계를 설정하고 레코드를 식별하는데 사용됩니다. 이를 통해서 빠르고 효율적인 데이터 검색과 테이블간의 Join을 통해 원하는 값을 가져오기 용이합니다.
    * **테이블에 대한 유일한 식별자**: 기본키는 해당 테이블에서 유일한 식별자 역할을 합니다. 따라서 어떤 레코드도 기본키를 공유할수 없습니다.
    * **일반적으로 기본키를 인덱스 생성**: 많은 데이터베이스 관리 시스템에서는 기본키를 이용하여 자동으로 인덱스를 생성해 빠른 검색이 가능합니다.
    * **자동 증가(Auto-increment)**: 많은 경우, 기본키는 자동으로 증가하는 값을 가집니다. 이는 주로 숫자형 데이터 타입에 해당되며, 새로운 레코드가 추가될때마다 기본키 값이 자동으로 증가하여 고유성을 유지합니다.
* 후보키(Candidate Key): 후보키는 관계형 데이터베이스에서 튜플들을 유일하게 식별할수있는 키(Key)의 하나이며 기본키로 선택될 수도 있는 키가 후보키입니다.
  * 특징
    * **유일성**: 모든 레코드는 서로 다른 후보키 값을 가져야합니다. 즉, 두개의 레코드가 동일한 후보키값을 가질수 없습니다.
    * **최소성**: 후보키를 구성하는 속성 중 하나라도 제거하면 더 이상 모든 레코드를 유일하게 식별할 수 없습니다.
  * 후보키를 세팅할시 주요 이점
    * **고유성 보장**: 후보키를 통해 테이블 내의 레코드를 고유하게 식별할수있습니다. 이를 통해 데이터 일관성을 유지합니다.
    * **데이터 무결성 유지**: 후보키를 통해 데이터 무결성을 유지할수있습니다. 즉, 잘못된 데이터가 테이블에 삽입되는것을 방지할수있습니다.
    * **검색 및 조작 성능 향상**: 후보키에 대한 인덱스를 생성하면 검색 및 조작 작업의 성능이 향상될수 있습니다.
    * **데이터베이스 설계의 명확성**: 후보키를 정의하면 데이터베이스 구조가 명확해지고 이해하기 쉬워집니다. 후보키를 통해 데이터의 구성 요소와 관계를 이해하고 관리할수 있습니다.
  * 기본키와 다른점: NULL값을 허용할수있고, 변경 가능성이 비교적 높으며, 테이블에서 여러개로 선택될수있습니다.
* 대리키(Alternate Key): 대리키는 관계형 데이터베이스의 관계 모델에서 관계의 '후보키'중 기본 키로 선정되지 않은 키를 말합니다.
* 슈퍼키(Super Key): 슈퍼키는 테이블 내의 모든 레코드를 고유하게 식별할수있는 속성 또는 속성 집합입니다. 즉, 슈퍼키는 후보키와 기본키의 상위 개념입니다. 슈퍼키는 후보키와 비슷한 개념이지만, 후보키보다 더 일반적인 개념입니다.
후보키는 유일성과 최소성의 조건을 모두 만족하는 슈퍼키의 특별한 경우입니다. 따라서 모든 후보키는 슈퍼키지만, 모든 슈퍼키가 후보키는 아닙니다.
  * 특징
    * **고유성(Uniqueness)**: 슈퍼키는 테이블 내의 모든 레코드를 고유하게 식별할수있습니다.
    * **최소성(Minimality)**: 슈퍼키를 구성하는 속성 중 하나라도 제거하면 더 이상 모든 레코드를 고유하게 식별할수 없습니다.
* 외래키(Foreign Key): 외래키는 관계형 데이터베이스에서 한 테이블의 필드가 다른 테이블의 기본키(Primary Key)를 참조하는 특별한 종류의 제약 조건입니다. 이를 통해 테이블 간의 관계를 설정하고 유지할 수 있습니다.
  * 특징
    * **참조 관계 설정**:외래 키는 다른 테이블의 기본 키 또는 유일 키를 참조합니다.
    * **무결성 제약 조건**: 외래키 제약은 데이터 무결성을 유지하는 데 중요한 역할을 합니다. 외래키를 통해 참조하는 테이블의 값은 반드시 참조되는 테이블의 주키와 일치해야 합니다. 이를 통해 부모 테이블에서 삭제되거나 수정되는 데이터에 대한 정합성을 보장할 수 있습니다.
    * **다양한 연산**: 외래키는 다양한 연산에 활용될 수 있습니다. 주로 데이터 검색, 조인 작업, 그리고 데이터의 관련성을 유지하는 데 사용됩니다.
    * **테이블 간의 관계 정의**: 외래키는 테이블 간의 관계를 명시적으로 정의하는 데 사용됩니다. 이를 통해 데이터베이스의 구조를 이해하고 쿼리를 작성할 때 테이블 간의 연관성을 파악할 수 있습니다. 예를 들어 두 테이블간의 1:N 또는 N:N 관계를 정의합니다.
  * 예시
    *  주문 테이블
    * | 주문번호 | 고객번호    | 상품 |
      |---|---------|---|
      | 1 | **100** | 컴퓨터 |
      | 2 | **200** | 스마트폰 |
      | 3 | **100** | 책 |
    * 고객 테이블
    * | 고객번호    | 이름 | 주소 |
      |---------|---|---|
      | **100** | 홍길동 | 서울 |
      | **200** | 김철수 | 부산 |
      | **300** | 이영희 | 대구 |
    * 주문 테이블의 고객번호 속성은 고객 테이블의 고객번호 속성을 참조하는 외래 키입니다.

- **기본키는 수정이 가능한가요?**
  * 일반적으로는 수정이 가능하지 않습니다. 만약에 기본키가 수정이 가능하다면 아래와 같이 2가지의 문제가 발생할수있습니다. <br>
    - 데이터 일관성 문제: 기본키가 다른 테이블의 외래키로 사용되고 있다면, 기본키 값을 변경하면 참조 무결성 제약조건에 위배될 수 있습니다. 다른 테이블에서 해당 값을 참조하고 있는 경우, 그 값을 변경하면 해당 참조가 유효하지 않아 일관성이 깨집니다. <br>
    - 인덱스와 성능 문제: 기본키는 대개 데이터베이스 시스템에 의해 인덱스로 사용되어 빠른 검색을 지원합니다. 기본키 값을 변경하면 해당 인덱스도 변경되어야 하므로 성능에 영향을 줄 수 있습니다.
  - 수정방안
    - 수정할수있는 방안은 기존 기본키 값이 다른 테이블에서 참조되고있는지 확인하고, 다른 테이블에서 외래키로 사용되는 경우에는 업데이트 해야합니다.
    - 데이터 베이스 관리 도구 또는 SQL 쿼리를 이용해서 기본키 값을 새로운값으로 수정해야합니다.
    - 기본키 값을 변경하면 해당 키에 인덱스 및 제약 조건도 업데이트해야합니다.
    - 테스트 및 확인을 통해 제대로 적용됐는지 확인합니다.
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  * Mysql에서는 기본키를 설정하지 않아도 테이블이 만들어지는 이유는 기본키 설정이 선택사항이기 때문입니다. 기본키를 설정하지 않을경우 히든 칼럼을 사용하여 테이블의 각 행을 식별합니다. <br> 그러나 사용자가 테이블에 기본키를 명시적으로 설정할수있기때문에 데이터베이스의 정확성과 무결성을 보장하기위해서는 기본키 설정은 필수입니다.
- **외래키 값은 NULL이 들어올 수 있나요?**
   * 네 가능합니다. 외래키가 참조하는 테이블의 값이 항상 존재하지 않을수도있기 떄문입니다. 따라서 외래키가 NULL값을 가질수 있도록 설정되어야합니다.
   * 하지만 외래키가 NULL값을 허용하는지 여부는 테이터베이스 설계자가 설정합니다. 떄로는 반드시 외래키가 유효한 값이어야 하는 경우가 있습니다. <br> 예를들어 *주문 테이블*에 *고객 ID* 외래키가 있을때, 모든 주문은 반드시 유효한 고객을 참조해야 한다면 NULL값을 허용하지 않을수 있습니다.
   * 따라서 데이터베이스의 요구사항과 비즈니스 논리에 따라 적절한 결정을 내려야합니다.
- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  * UNIQUE 키워드는 지정된 열(속성)에는 중복된 값을 허용하지 않음을 나타냅니다. 즉 데이터베이스의 무결성을 보장하는데 사용됩니다.
  * 해당 키워드가 설정된 열은 인덱스를 자동으로 생성하여 검색 작업의 성능을 향상시킬수있습니다.

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**
RDB는 테이블 기반의 정형 데이터를 저장히기 적합한 구조로 되어있으며, Nosql은 비정형데이터로 Key-value, Document, Column, Graph 등 다양한 형태로 되어있습니다. <br>RDB는 엄격한 데이터를 구현하기에 적합하며, 데이터 중복없이 한번 만 저장 즉 무결성을 지키기 적합니다. NoSql은 유연한 데이터 구조를 가지고있으며, 새로운 필드에 대한 추가가 자유롭고 수평적 확장(Scale out)에 용이합니다.
즉 RDB는 ACID의 특성, Transaction을 지원하며 데이터에 저장에 대한 정합성을 보장하고있으며, NoSql은 Transaction을 지원하지 않으며 데이터의 저장에 대한 유연한 구조를 가지고있습니다.</br>
그래서 RDB는 데이터 구조가 변경될 여지가 없이 명확하며 데이터의 Update가 잦은 시스템에 적합하며, Nosql은 정확히 데이터 구조가 정해지지않고, Update가 자주 이뤄지지 않으며 데이터 양이 많아서 수평적 확장이 필요한 경우 적합합니다.

- **NoSQL의 강점과, 약점이 무엇인가요?**
  - 강점
    - 유연한 데이터 구조: NoSQL은 유연한 데이터 구조를 가지고 있어서 데이터의 구조가 변경될 여지가 없이 명확하지 않은 경우에 적합합니다.
    - 수평적 확장: NoSQL은 수평적 확장이 용이하여 데이터의 양이 많아서 수평적 확장이 필요한 경우에 적합합니다.
    - 빠른 속도: NoSQL은 데이터의 저장과 검색에 있어서 빠른 속도를 가지고 있습니다.
  - 약점
    - 데이터의 일관성: NoSQL은 데이터의 일관성을 보장하지 않기 때문에 데이터의 일관성이 중요한 경우에는 적합하지 않습니다.
    - 표준화된 쿼리 언어의 부재: NoSQL은 표준화된 쿼리 언어가 없기 때문에 데이터의 검색이 어려울 수 있습니다.
    - ACID의 특성: NoSQL은 ACID의 특성을 지원하지 않기 때문에 데이터의 무결성이 중요한 경우에는 적합하지 않습니다.
- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**
  - RDB는 ACID 트랜잭션, 정교한 쿼리, 스키마 등의 특징때문에 NoSQL에 비해 부하가 많이 걸릴 수 있습니다. 
- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**
  - 검색 데이터 같은경우 Nosql이 적합했으며 검색 시스템 DB로 주로 활용하는 ElasticSearch를 사용했었습니다. 해당 데이터를 통해 수천만건의 Document 데이터들을 역색인이라는 Elasticsearch의 특성으로 빠르게 검색할수있었으며, Clustering을 통해 부하를 분산하고 데이터를 확장 복제를 유용하게 진행했었습니다.

### **3. 트랜잭션이 무엇이고, 3.ACID 원칙에 대해 설명해 주세요.**
트랜잭션은 데이터베이스에서 여러 작업을 하나의 단위로 묶어 처리하는 작업입니다. 트랜잭션은 다음과 같은 특징을 가집니다.

1. 원자성(Atomicity): 트랜잭션은 모든 작업이 완료되거나 아무것도 수행되지 않습니다. 즉, 트랜잭션 내 작업은 일부만 성공하거나 일부만 실패하는 경우가 없습니다.
2. 일관성(Consistency): 트랜잭션은 데이터베이스의 일관성을 유지해야 합니다. 즉, 트랜잭션이 수행되기 전후로 데이터베이스의 상태는 일관성을 유지해야 합니다.
3. 격리성(Isolation): 트랜잭션은 서로 영향을 주지 않습니다. 즉, 한 트랜잭션에서 발생하는 변경 사항은 다른 트랜잭션에서 수행될 때까지 보이지 않습니다.
4. 영속성(Durability): 트랜잭션이 완료되면 변경 사항은 영구적으로 저장됩니다. 즉, 시스템 장애가 발생해도 변경 사항은 손실되지 않습니다.
- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**
다양한 방법으로 Durability를 보장합니다.
1. 트랜잭션의 변경 사항을 로그에 기록하고 시스템 장애 발생시 해당 로그를 사용하여 트랜잭션을 복구하거나 롤백합니다. 대표적인 기법으로는 Redo Logging과 Undo Logging이 있습니다.
   - Redo Logging: Redo Log란 DB 장애발생시 복구에 사용되는 Log, 즉 더 정확하게 설명하자면 MySQL 장애 시 Buffer pool에 저장되어 있던 데이터의 유실을 방지(데이터 복구)하기 위해 사용된다.
   - Undo Logging: 실행 취소 로그 레코드의 집합으로 트랜잭션 실행 후 Rollback 시 Undo Log를 참조해 이전 데이터로 복구할 수 있도록 로깅 해놓은 영역이다.
2. 클러스터링을 구축하여 여러 서버를 하나의 시스템처럼 작동하도록 연결하여 시스템 장애 발생시에도 데이터를 유지시킵니다.
- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**
  - 은행 계좌에 대한 입출금 송금 결제 투자 혹은 전자 상거래 사이트에서 상품 구매, 결제나 상품에 대한 주문, 배송, 입출고 관리 등 데이터의 정합성이 중요한 도메인에 주로 사용했었습니다. 

- **읽기에는 트랜잭션을 걸지 않아도 될까요?**
  - 상황에 따라 다릅니다. 데이터의 일관성이 보장해야하고, 여러 테이블에서 동시에 데이터를 읽고, 읽은 데이터를 기반으로 업데이트 작업을 수행하거나, 다른 트랜잭션의 변경 사항을 보지 않고 데이터를 읽어야하는 경우에는 트랜잭션을 적용해야하고, <br> 성능 향상이 필요하거나 단순 읽기 작업은 사용하지 않아도 됩니다. 

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**
- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
- **그렇다면 외래키는요?**
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**

### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**

### **8. View가 무엇이고, 언제 사용할 수 있나요?**

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**

### **11. DB Locking에 대해 설명해 주세요.**

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**
- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**

### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**

### **13. Schema가 무엇인가요?**

- **Schema의 3계층에 대해 설명해 주세요.**

### **14. DB의 Connection Pool에 대해 설명해 주세요.**

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**

### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**

- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**
