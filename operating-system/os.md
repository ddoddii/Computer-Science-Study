### Operating System

<details>
<summary>📚 공부한 자료</summary>

- 혼자 공부하는 컴퓨터구조 / 운영체제
- 실습과 그림으로 배우는 리눅스 구조
- Operating System Concepts

</details>

### **1. 시스템 콜이 무엇인지 설명해 주세요.**
Answer : 프로그래밍 인터페이스로, 커널 영역의 기능을 응용 프로그램이 사용 가능하게 합니다. 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 할 수 있게 해줍니다.
- **우리가 사용하는 시스템 콜의 예시를 들어주세요.**
  - Answer : 우리가 사용하는 시스템 콜의 일부 예시로는 파일을 열고 읽고 쓰기 위해 사용되는 open, read, write와 소켓통신을 위한 socket등이 있습니다.
- **시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.**
  - Answer : 응용 프로그램이 운영체제의 서비스를 필요로 할 때, 해당 서비스를 요청하는 시스템 콜을 호출하게 됩니다. 시스템 콜 호출로 인해 사용자 모드에서 커널 모드로 전환이 됩니다. 커널은 호출된 시스템 콜을 식별하고 해당 서비스를 처리하기 위해 필요한 작업을 수행합니다. 시스템 콜이 성공적으로 처리되면, 커널은 결과를 응욜프로그램에 반환합니다. 이때 커널 모드에서 사용자 모드로 다시 전환되고 기존의 응용 프로그램이 계속 실행됩니다. 시스템 콜은 일종의 소프트웨어 인터럽트로 CPU가 시스템 콜을 처리하는 순서는 인터럽트 처리 순서와 유사합니다. 시스템 콜이 호출되면 CPU는 지금까지의 작업을 백업하고, 인터럽트 서비스 루틴을 실행한 뒤 다시 응용 프로그램으로 복귀합니다.
- **시스템 콜의 유형에 대해 설명해 주세요.**
  - Answer : 시스템 콜은 크게 세 가지 유형으로 분류됩니다. 첫 번째는 프로세스 제어(System Control) 시스템 콜로, 프로세스의 생성, 종료, 일시 정지, 재개 등의 제어를 위해 사용됩니다. 두 번째는 파일 조작(File Manipulation) 시스템 콜로, 파일의 생성, 삭제, 읽기, 쓰기, 오픈, 닫기 등 파일 관련 작업을 수행하기 위해 사용됩니다. 마지막으로, 장치 제어(Device Control) 시스템 콜은 주변장치(하드웨어)의 제어를 위해 사용됩니다. 이러한 시스템 콜은 입출력 작업, 네트워크 통신 등과 관련된 작업을 처리하는 데 사용됩니다.
- **운영체제의 Dual Mode 에 대해 설명해 주세요.**
  - Answer : 듀얼 모드란 CPU가 명령어를 실행하는 모드를 사용자 모드와 커널 모드로 구분하는 방식입니다. 사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행모드입니다. 즉, 커널 영역의 코드를 실행할 수 없는 모드로 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행됩니다. 커널 모드는 운영체제 서비스를 제공받을 수 있는 실행모드입니다. 커널 영역의 코드를 실행할 수 있는 모드로 CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있습니다.
- **왜 유저모드와 커널모드를 구분해야 하나요?**
  - 만약 응용 프로그램이 하드웨어에 마음대로 조작하고 접근할 수 있다면 자원은 무질서하게 관리될 것이고, 응용 프로그램이 조금만 실수해도 컴퓨터 전체에 큰 악영향을 끼칠 수 있습니다. 그래서 운영체제는 응용 프로그램들이 자우너에 접근하려고 할 때 오직 자신을 통해서만 접근하여 자원을 보호할 수 있도록 이중모드로써 구현한것입니다.

- **서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?**

### **2. 인터럽트가 무엇인지 설명해 주세요.**
Answer : 운영체제에서 발생하는 이벤트나 신호입니다. 프로그램 실행 도중 입출력 하드웨어 등의 장치나 예외상황 같은 예기치 않은 상황이 발생하여 처리가 필요할 경우에, 현재 실행 중인 작업을 중단하고 발생한 상황에 대해 우선 처리해야 함을 CPU에게 알리는 것입니다.
- **인터럽트는 어떻게 처리하나요?**
  - Answer : CPU가 인터럽트를 확인하면 현 상태의 정보를 시스템 스택에 저장합니다. 그 후에 인터럽트 벡터를 읽어 인터럽트 처리 루틴의 시작 주소를 프로그램 카운터에 넣고 인터럽트 서비스 루틴을 실행합니다. 루틴 실행이 끝나면 원래의 레지스터 값을 복원하고 프로그램의 실행을 계속 이어나갑니다.
- **Polling 방식에 대해 설명해 주세요.**
  - Answer : 주기적으로 인터럽트가 있는지 확인하는 소프트웨어적 방식입니다. 별도의 하드웨어가 필요 없어서 경제적이나, 많은 인터럽트가 있을 경우 모두 조사하는데 시간이 걸려 처리 속도가 느린 단점이 있습니다.
- **HW / SW 인터럽트에 대해 설명해 주세요.**
  - Answer : 인터럽트를 발생시킨 주체에 따라 나눈 인터럽트들입니다. 하드웨어 인터럽트는 하드웨어가 발생시키는 인터럽트로, CPU가 아닌 하드웨어 장치가 CPU에게 어떤 사실을 알려주거나, 서비스를 요청해야 할 경우 발생시킵니다. 대표적으로 전원 이상 인터럽트, 타이머에 의한 인터럽트, 입출력 인터럽트 등이 있습니다. 소프트웨어 인터럽트는 CPU 외부에서 발생하는 인터럽트와는 달리 CPU 내부에서 발생하는 신호들입니다. 명령어를 실행하다가 만나게 되는 문제점들에 대해 CPU가 스스로 발생시키는 신호입니다. 예외나 페이지 부재, 트랩 같은 경우가 있습니다.
- **동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?**
  - Answer : 우선순위를 따져서 처리하게 됩니다. 일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선순위가 높습니다. 우선순위를 판별하는 방식으로는 소프트웨어적인 방식과 하드웨어적인 방식이 있습니다. 소프트웨어적인 방식은 폴링으로 주기적으로 인터럽트가 있는지 확인하고 높은 우선순위의 인터럽트를 먼저 수행합니다. 하드웨어적인 방식은 CPU와 인터럽트를 요청할 수 있는 장치 사이에 해당하는 버스를 직렬이나 병렬로 연결하여 요청 장치의 번호를 CPU에게 알리는 방식입니다. 해당 방식에는 데이지체인과 병렬 우선순위 방식이 있습니다.  
### **3. 프로세스가 무엇인가요?.**

- **프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.**

- **프로세스 상태는 어떤 것이 있나요?**

- **PCB가 무엇인가요?**

- **그렇다면, 스레드는 PCB를 갖고 있을까요?**

  - **스레드와 PCB**
  - **스레드 관리 방식**

- **리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?**
- **자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?**
- **리눅스에서, 데몬프로세스에 대해 설명해 주세요.**

- **리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.**
- **프로세스와 쓰레드가 실제 사용되는 예시에 대해 설명해 주세요.⭐️**

### **4. 프로세스 주소공간에 대해 설명해 주세요.**

- **프로세스의 4가지 영역은 무엇인가요?**

- **초기화 하지 않은 변수들은 어디에 저장될까요?**
- **일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?**
- **Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?**
- **다음과 같이 공간을 분할하는 이유가 있을까요?**
- **스레드의 주소공간은 어떻게 구성되어 있을까요?**

- **"스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.**
- **그렇다면 동적 메모리 할당이란 무엇인가요? 여기서 메모리 누수는 어떤 상황일 때 발생할까요?**
- **IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?**
- **스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?**
- **재귀함수의 작동 원리를 call stack 과 관련해서 설명해주세요.**

### **5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.**

- **현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?**
- **프로세스의 스케쥴링 상태에 대해 설명해 주세요.**
- **preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?**
- **Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?**

### **6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?**
CPU 레지스터에 존재하는 프로세스 및 스레드의 정보가 변경이 됩니다. 그러기 위해선 커널 모드로 전환을 하고 CPU 레지스터의 상태를 교체하는 작업을 수행합니다.
- **프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?**
  
  - CPU 레지스터의 상태를 교체하는 과정에서 차이가 있습니다. 프로세스와 스레드 둘다 현재 실행 중인 프로세스 및 스레드의 context를 백업하는 과정을 거치는건 같습니다.
         다만 프로세스 컨텍스트 스위칭은 상태를 백업할 뿐만 아니라 캐시 및 TLB를 비워주고 가상 메모리 주소에서 물리적인 메모리 주소로 변환하는 역할을 하는 MMU 설정을 변경하는 작업을 추가적으로 수행합니다.
  
- **컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?**
  - 현재 실행중인 프로세스의 레지스터 값을 저장, 프로세스 상태 저장, 현재 실행중이 프로세스의 스택 메모리 영역의 내용이 커널 스택에 저장됩니다.
- **컨텍스트 스위칭은 언제 일어날까요?**
  - 주어진 CPU 사용 시간이 다 되었을 경우, 인터럽트가 발생할 경우, 우선순위가 더 높은 task가 선점할 경우 발생합니다.
### **7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**

- **RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.**

- **싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?**

- **동시성과 병렬성의 차이에 대해 설명해 주세요.**
- **타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?**

- **FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?**
- **우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?**

- **유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?**

### **8. 뮤텍스와 세마포어의 차이점은 무엇인가요?**
공유 자원에 대한 동시 접근을 제한 하는 갯수와 소유 가능 여부에 차이가 있습니다.뮤텍스는 자원에 대한 접근을 하나의 스레드만에게 허용합니다. 세마포어는 공유 자원에 대해 여러 스레드의 접근을 허용합니다. 또한 뮤텍스는 뮤텍스를 소유한 스레드만이 뮤텍스를 해제할 수 있지만, 세마포어는 소유하지 않는 동기화 기법으로 세마포어를 획득한 스레드가 아니어도 세마포어를 해제할 수 있습니다.
- **이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.**
  - 락을 해제하는 주체가 누구한테 있냐가 차이입니다. 뮤텍스는 락을 얻은 스레드만이 락을 해제할 수 있고 이진 세마포어는 락을 설정한 스레드와 해제하는 스레드가 다를 수 있습니다.
- **Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?**
  - 컨텍스트 스위칭이 필요하지 않아 부하를 주지 않는 장점이 있습니다. 그러나 자원을 얻을때 까지 무한루프를 돌면서 CPU를 양보하지 않기 때문에 시스템 성능에 부정적인 영향을 줄 가능성이 있다는 단점이 있습니다. 단점을 해결하기 위해선 Ticket Lock, MCS Lock 등과 같은 대기열 기반의 Spin Lock 알고리즘을 사용합니다. 이러한 알고리즘은 대기하는 프로세스들이 순서대로 Lock을 얻도록 보장하여 경쟁 상태를 줄일 수 있습니다.  
- **뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?**
  - 동기화를 위한 기능을 운영체제가 제공하기 때문에 안전하고 신뢰할 수 있습니다. 그러나 시스템 콜은 CPU의 권한 모드 전환과 커널 공간으로의 메모리 접근 등 추가 작업이 필요하며, 이로 인해 성능 저하가 발생할 수 있는 단점도 있습니다. 단점을 해결하기 위해선 Busy-waiting을 최소화하기 위해 대기 대기열(Blocking Queue)을 사용할 수 있습니다.
### **9. Deadlock 에 대해 설명해 주세요.**

- **Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.**

- **그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?**
- **어떤 방식으로 예방할 수 있을까요?**
- **왜 현대 OS는 Deadlock을 처리하지 않을까요?**
- **Wait Free와 Lock Free를 비교해 주세요.**

### **10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.**

- **링커와, 로더의 차이에 대해 설명해 주세요.**
- **컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.**
- **JIT(Just-In-Time) Compiler 에 대해 설명해 주세요.**

- **본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.**
- **Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?**
- **우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?**

### **11. IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.**

- **Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.**
- **메시지 큐는 단방향이라고 할 수 있나요?**

### **12. Thread Safe 하다는 것은 어떤 의미인가요?**

- **Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?**
- **Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.**
- **Race Condition 이 무엇인가요?**

- **Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?**

### **13. Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.**

- **Thread Pool을 사용한다고 가정하면, 어떤 기준으로 스레드의 수를 결정할 것인가요?**
- **어떤 데이터를 정렬 하려고 합니다. 어떤 방식의 전략을 사용하는 것이 가장 안전하면서도 좋은 성능을 낼 수 있을까요?**

### **14. 캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.**

- **캐시 메모리는 어디에 위치해 있나요?**
- **L1, L2 캐시에 대해 설명해 주세요.**
- **캐시 히트, 캐시 미스, 캐시 적중률이란 무엇인가요?**

- **캐시에 올라오는 데이터는 어떻게 관리되나요?**
- **캐시간의 동기화는 어떻게 이루어지나요?**
- **캐시 메모리의 Mapping 방식에 대해 설명해 주세요.**
- **캐시의 지역성에 대해 설명해 주세요.**
- **캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.**

- **캐시의 공간 지역성은 어떻게 구현될 수 있을까요? (힌트: 캐시는 어떤 단위로 저장되고 관리될까요?)**

### **15.메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)**

- **worst-fit 은 언제 사용할 수 있을까요?**

- **성능이 가장 좋은 알고리즘은 무엇일까요?**

### **16. Thrashing 이란 무엇인가요?**

- **Thrashing 발생 시, 어떻게 완화할 수 있을까요?**

### **17. 가상 메모리란 무엇인가요?**

- **가상 메모리가 가능한 이유가 무엇일까요?**
- **Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.**
- **페이지 크기에 대한 Trade-Off를 설명해 주세요.**

- **가상 메모리를 사용하는 이유가 무엇일까요 ? 스왑 말고 더 중요한 이유는 어떤 것이 있을까요?⭐️**

### **18. 세그멘테이션과 페이징의 차이점은 무엇인가요?**
Answer : 물리적 메모리 크기의 한계를 극복하기 위해 나온 기술이다. 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두는것이 가상 메모리 기술입니다. 이를 통해 프로세스 전체가 물리적 메모리에 있는것처럼 수행합니다.
- **페이지와 프레임의 차이에 대해 설명해 주세요.**
  - Answer : 페이지는 프로세스를 고정 크기로 분할한것입니다. 프레임은 메모리를 페이지와 같은 고정 크기로 분할한 것입니다.
- **내부 단편화와, 외부 단편화에 대해 설명해 주세요.**
  - Answer : 내부 단편화는 메모리 할당 시 발생하는 현상으로, 프로세스가 요구한 메모리보다 더 큰 메모리 블록이 할당되어 발생합니다. 이로 인해 할당된 메모리 블록의 일부 공간이 사용되지 않고 낭비되는 것을 의미합니다. 내부 단편화는 주로 고정 크기의 메모리 할당 방식에서 발생하는 문제입니다.
외부 단편화는 메모리 할당과 해제의 반복으로 인해 발생하는 현상으로, 사용 가능한 메모리 공간이 작은 조각들로 나누어져 사용할 수 없는 상태가 되는 것을 의미합니다. 이로 인해 메모리에는 충분한 공간이 있는데도 프로세스의 할당 요청을 수용할 수 없는 상황이 발생할 수 있습니다.
- **페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.**
  - Answer : 페이지 테이블을 통해 가상주소를 물리주소로 변환하여 실제 주소를 가져옵니다. 
- **어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?**
- **32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?**
- **32비트 운영체제는 램을 최대 4G 까지 사용할 수 있습니다. 이 이유를 페이징과 연관 지어서 설명해 주세요.**
- **C/C++ 개발을 하게 되면 Segmentation Fault 라는 에러를 접할 수 있을텐데, 이 에러는 세그멘테이션/페이징과 어떤 관계가 있을까요?**

### **19. TLB는 무엇인가요?**
Answer : TLB는 주소 변환을 빠르게 하기 위한 캐시 메모리입니다. 
- **TLB를 쓰면 왜 빨라지나요?**
  - Answer : 페이지 테이블은 프로그램마다 존재하는데, 이 페이지 테이블은 메모리에 저장됩니다. 메모리에 접근하기 위해서는 주소가 필요한데 주소 접근하려면 메모리에 접근해야 하기 때문에 결과적으로 메모리에 두번 접근하게 됩니다. 이러한 방식은 비효율적이기 때문에 매번 메모리에 접근하여 주소 변환을 수행하는 것보다 TLB에 변환 결과가 저장되어 있다면, CPU는 TLB에서 변환 결과를 직접 가져와 사용할 수 있어서 메모리 액세스의 지연 시간을 줄일 수 있습니다.
- **MMU가 무엇인가요?**
  - Answer : MMU는 "Memory Management Unit"의 약자로, 컴퓨터 시스템에서 가상 주소와 물리 주소 간의 변환을 담당하는 하드웨어 장치입니다.
- **TLB와 MMU는 어디에 위치해 있나요?**
  - Answer :  TLB는 CPU나 메모리 컨트롤러에 위치하며, MMU는 CPU 내부에 위치합니다.
- **코어가 여러개라면, TLB는 어떻게 동기화 할 수 있을까요?**
  - Answer : 일반적으로 코어 간 TLB의 동기화는 캐시 일관성 프로토콜을 통해 처리됩니다. 캐시 일관성 프로토콜은 캐시와 메모리 사이의 데이터 일관성을 유지하기 위한 규칙과 프로세스입니다. 이 프로토콜은 캐시 간 데이터의 일관성을 유지하면서 동시에 코어 간 TLB의 일관성도 유지합니다.
대표적인 캐시 일관성 프로토콜로는 MESI(Modified, Exclusive, Shared, Invalid)와 MOESI(Modified, Owned, Exclusive, Shared, Invalid) 프로토콜이 있습니다. 이 프로토콜은 코어 간 데이터 및 TLB의 상태를 추적하여 변경된 데이터를 공유하거나 동기화하는 방식을 정의합니다.
- **TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요.**
  - Answer : 일반적으로 Context switch가 발생하면 기존 프로세스의 정보가 더 이상 유효하지 않기 때문에 지워버리는 flush(초기화)를 수행합니다. 몇몇 고급 시스템에서는 TLB 엔트리에 태그를 추가하여 각 엔트리가 어느 프로세스의 주소 공간에 속하는지 식별할 수 있도록 하여 컨텍스트 스위칭시마다 flush를 수행하지 않습니다.

### **20. 동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.**

- **volatile 키워드는 어떤 의미가 있나요?**
- **싱글코어가 아니라 멀티코어라면, 어떻게 동기화가 이뤄질까요?**

### **21. 페이지 교체 알고리즘에 대해 설명해 주세요.**

- **LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?**
- **LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?**
- **LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.**

### **22. File Descriptor와, File System에 에 대해 설명해 주세요.**

- **I-Node가 무엇인가요?**
- **프로그래밍 언어 상에서 제공하는 파일 관련 함수 (Python - open(), Java - BufferedReader/Writer 등)은, 파일을 어떤 방식으로 읽어들이나요?**

### **23. 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.**

### **24. 멀티프로세싱과 멀티쓰레딩의 차이는 무엇인가요?⭐️**

- **그렇다면 멀티쓰레딩의 문제점이라고 했을 때 실제 예시는 무엇인가요?**
- **멀티쓰레딩의 문제점을 멀티프로세싱이 해결해줄 수 있나요?**
- **python 을 사용한다고 했을 때, 멀티쓰레딩의 문제를 asyncio 가 해결할 수 있나요?**
- **asyncio 를 멀티쓰레딩 대신 사용하라고 하는 이유는 무엇일까요?**
