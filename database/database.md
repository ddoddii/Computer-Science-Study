### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
  ```
   키는 데이터 베이스에서 레코드를 식별하기 위한 값으로 쓰입니다. 키가 되기 위해서는 '유일성'을 만족해야합니다.
   좋은 키는 '최소성'을 만족해야합니다. 최소성이란, 최소한의 컬럼으로 값의 유일성을 보장하는 성질입니다.
   - 기본키(PK)는 테이블에서 레코드를 식별하기 위해 대표로 선택된 키 입니다.
   - 후보키는 '유일성'을 만족하는 키 들의 집합입니다.
   - 자연키(natural key)는 테이블을 이루는 컬럼 중, 도메인 적인 의미를 가지는 비즈니스 모델에서 자연스럽게 추출된 속성값을 키로 삼는 것
   - 대체키(surrogate key, =인공키)는 도메인적인 의미가 없는 임의의 키를 데이터 식별을 위한 PK로 삼는 것
  ```
- **기본키는 수정이 가능한가요?**
  ```
  외래키로 다른 테이블에서 참조하고 있지 않은 경우(외래키 제약 조건 없는 경우)에는 수정이 가능합니다. 
  
  외래키 제약이 걸려 있고 수정이 필요한 경우, 아래 방법을 사용할 수 있습니다.
  1. 외래키 제약조건을 잠시 해제 하고 수정 
     -> 데이터 정합성을 위해 권장되는 작업은 아닙니다.
  2. update가 아니라, 새로운 데이터 insert
     - 변경하려는 값을 새로 insert 한 후, FK들을 새로 insert 된 데이터의 PK로 교체하고, 그 후 이전의 PK 데이터를 delete합니다.
  ```
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  ```
  MySQL(InnoDB)에서는 기본키가 없어도 테이블이 만들어 지는데, PK가 없을 경우, 테이블에서 자체적으로 레코드를 식별할 수 있는 ROWID라는 값을 부여하도록 이루어집니다.
  MSSQL에서도 이와 유사한 개념이 존재하는데, MSSQL에서는 RID라고 부릅니다.
  ```
- **외래키 값은 NULL이 들어올 수 있나요?**
  ```
  NULL 제약 조건이 없는 경우 가능한 것으로 알고 있습니다.
  ```

- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  ```
  1. insert와 update 성능
    - 해당 값이 유일한지 확인하는 추가적인 프로세스가 들어가므로 기존보다 성능은 떨어질 수 있습니다.
  2. select 성능
    - Unique 제약 조건을 추가한 컬럼에는 인덱스(비클러스터 인덱스)가 생성됩니다.(mysql, mssql)s 인덱스 컬럼을 조회한 것과 같은 조회 성능 증가 효과를 볼 수 있습니다. 
  ```

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

- **NoSQL의 강점과, 약점이 무엇인가요?**
- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**
- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**

### **3. 트랜잭션이 무엇이고, 3.ACID 원칙에 대해 설명해 주세요.**
  ```
  트랜잭션은 DB의 작업을 하나로 묶어주는 것을 말합니다. 하나로 묶인 작업은 반영시 모두 반영되거나, 취소시 일괄 취소됩니다. 
  이는 동시성이 높은 환경에서 데이터의 일관성을 유지하는 데 중요합니다.
  
  트랜잭션은 아래 4가지 성질이 있습니다.
  Atomic(원자성): 작업의 원자성을 보장합니다. 모두 취소되거나, 모두 반영됩니다.
  Consistency(일관성): 트랜잭션이 시작되기 전과 후에 데이터베이스는 일관된 상태를 유지해야합니다.
  Isolation(고립성): 트랜잭션 끼리는 고립되어 서로 영향을 주고 받으면 안됩니다.
  Durability(영구성): 트랜잭션이 커밋되면 그 결과는 영구히 저장되어야합니다. 장애가 발생하더라도 복구할 수 있도록 해야합니다.
  ```

- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**
  ```
  Durability는 어떤 상황(장애 상황)에서도 데이터를 보존해야하는 성질로, DB에서는 '데이터 보존'과 관련된 부차적인 기능들을 제공합니다.
  Durability는 사용자의 실수나 하드웨어 장애 등의 상황에 대응을 수 있는 수단이 됩니다. 로깅, 체크포인트, 복제, 백업등의 기능이 있습니다.
  ```
- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**\
  ```
  트랜잭션은 여러작업을 원자적으로 묶어서 처리하기에, 하나의 로직이 여러건의 DML을 날려야할 경우 필수적입니다. 
  만약 한건이 실패하면 이미 실행된 건들도 Rollback 될 수 있으며 이는 데이터의 신뢰성을 높혀줍니다.
  또한 트랜잭션은 웹과 같은 동시성이 높은 환경에서 데이터를 보호할 수 있습니다. 
  예를 들러, 트랜잭션은 READ COMMITTED 의 고립수준에서 커밋되지 않은 데이터는 타 세션에서 수정 전 데이터를 읽게 하여 데이터의 일관성을 유지시킬 수 있습니다. 
  ```
- **읽기에는 트랜잭션을 걸지 않아도 될까요?**
  ```
  읽기에는 보통 트랜잭션을 걸지 않아도 되나, 읽기 작업에 높은 일관성을 유지하려면 유지하려는 경우 트랜잭션으로 묶어서 사용할 수 있습니다.
  예를 들어, 격리는 트랜잭션 단위로 이루어 지기 때문에 Repeatable Read나 Serializable 같은 읽기에도 일관성을 지키도록하는 높은 격리 수준을 사용하는 경우 사용할 수 있습니다.
  ```

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**
  ```
  트랜잭션 격리 레벨에는 Read Uncommitted, Read Committed, Repeatable Read, Serializable 이 있습니다.
  격리 수준에 따라 동시성이 높으면 성능이 높고 동시성이 낮으면 성능이 낮습니다.
  ```
- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
  ```
  대부분의 DB들이 4개의 격리 수준을 가지고 있습니다. 하지만 격리를 어떻게 구현하는지는 DBMS 마다 다르기 때문에 상세한 구현 내용은 다를 수 있습니다.
  예를 들어, DB에서 동시성을 컨트롤하기 위한 MVCC 매커니즘 같은 경우에, 변경된 데이터와 이전데이터를 동시에 관리하기 위해
  Mysql 은 변경된 데이터를 undo 영역에 버전을 증가시켜 insert 시키는 반면, mssql 은 변경 이전 데이터를 snapshot을 만들어 보관하여 둡니다.  
  ```
- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**
  ```
  undo 영역과 redo 영역은 모두 트랜잭션이 데이터를 변경한 로그를 저장하는 영역입니다. 
  undo 영역은 커밋하기 전 트랜잭션으로 변경된 데이터를 롤백시키는 용도로 사용되거나, 여러 사용자가 접근할때 동시성을 제어하기 위한 MVCC 를 위해 사용됩니다.
  redo 영역은 트랜잭션이 변경한 데이터의 로그를 모두 저장해 두고, 장애 발생시, DB를 복구하려는 목적으로 사용됩니다.
  ```
- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**
  ```
  스토리지 엔진은 DBMS에 데이터를 조회, 저장, 수정, 삭제 하는 방식을 결정하는 소프트웨어 입니다. 
  스토리지 엔진은 데이터 저장 방식이나 인덱스 생성 방법 등 데이터를 관리하는 물리적인 방식도 정의합니다.
  예를들어, mysql 은 여러 스토리지 엔진을 제공하여 사용자가 선택할 수 있도록 제공합니다. 종류는 innodb, myISAM, Memory 가 있습니다.
  ```

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
- **그렇다면 외래키는요?**
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**

### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**

### **8. View가 무엇이고, 언제 사용할 수 있나요?**
  ```
  View는 Select 조회된 결과를 테이블로 다룰 수 있도록 하는 가상테이블의 역할을 합니다. 물리적으로 테이블이 만들어 지는 것은 아니고, 뷰가 실행될 때, 조회문도 실행됩니다. 
  다만, 1. 복잡한 조회문(조인이 많은 경우 등)을 간소화 시킬 수 있다는 점과, 2. 권한에 따라 일부 데이터만 뷰로 공개하는 등의 보안성을 이유로 사용됩니다.
  ```

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**
  ```
  뷰를 통해 수정한 데이터도 원본 테이블에 반영되는 케이스는 있습니다. 하지만, 데이터 베이스나 상황에 따라 다르기 때문에 일관성을 위해
  꼭 필요한 경우가 아니면 뷰를 수정하는 로직은 지양하는 것이 좋을 것 같습니다.
  ```

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**

### **11. DB Locking에 대해 설명해 주세요.**

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**
- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**

### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**

### **13. Schema가 무엇인가요?**

- **Schema의 3계층에 대해 설명해 주세요.**

### **14. DB의 Connection Pool에 대해 설명해 주세요.**

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**

### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**
  ```
  sql 인젝션이란, 악의적인 목적의 사용자가 sql의 파라메터에 다른 sql문을 삽입하여 원래의 목적과 다른 SQL문이 실행되도록 하는 보안 공격입니다.
  ```
- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**
  ```
  언어에 따라 제공되는 DB 접근을 위한 라이브러리들은 모두 SQL Injection을 방지하기 위한 조치를 하고 있습니다. 
  대표적인 방법으로는 Prepared Statement를 사용하여 방지하고 있습니다. Prepared Statement는 미리 컴파일된 SQL문을 파라메터와 분리하여 DB로 전달합니다.
  파라메터는 문자열로 변환되거나, 적절하게 escape 처리 되는 등의 과정을 거치고, 기존의 SQL문을 악의적인 형태로 변경할 수 없도록 조치합니다.
  ```
