## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️

JVM이란 _Java 언어와, Java bytecode 로 컴파일 된 다른 언어들도 실행할 수 있게 해주는 환경을 만들어주는 가상 머신_ 입니다. 프로그래머가 작성한 언어를 컴퓨터가 이해하고 실행하기 위해서는 기계어로 컴파일 해야 합니다. Java(\*.java) 를 Java bytecode(\*.class) 로 컴파일 하는 것은 java compiler 가 합니다. Java bytecode 를 실제 기계어로 해석하는 일을 JVM 이 담당합니다.

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 있습니다. JVM 은 Java bytecode를 인식합니다. 즉, Java bytecode 로 컴파일 될 수 있는 다른 언어들도 실행할 수 있습니다. 대표적으로는 Scala, Groovy, Kotlin 등이 있습니다.
- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**

  - JVM 계열 언어도 직접 기계어로 변환해서 사용할 수 있습니다. 일부 JVM 구현체는 Ahead-Of-Time(AOT) 컴파일을 지원하여, 바이트코드를 실행 전에 기계어로 미리 컴파일할 수 있습니다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - 전통적인 의미의 "부모 프로세스-자식 프로세스" 로 보는 것은 정확하지 않습니다. JVM이 실행될 때, 운영체제는 JVM을 위한 프로세스를 생성합니다. 이 JVM 프로세스 내에서 자바 프로그램이 실행되며, 이것은 운영체제에 의해 별도의 자식 프로세스가 생성되는 것이 아닌 JVM 프로세스의 일부로 실행됩니다. 따라서 JVM 내부에서 실행되는 자바 프로그램은 JVM 프로세스의 스레드로서 작동합니다.
- **Java bytecode란 무엇인가요?**
  - Java bytecode 란 JVM 이 이해할 수 있는 언어로 변환된 자바 소스코드입니다. Java 컴파일러에 의해 변환된 코드의 명령어 크가 1 byte 라서 바이트 코드라고 불립니다.
- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일, 인터프리터 방식 모두 사용합니다. 우선 자바 컴파일러가 자바 바이트코드 로 컴파일 한다는 면에서 컴파일 언어의 특성을 가지고 있습니다. 하지만 자바 바이트코드는 JVM의 자바 인터프리터가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 바이너리 코드로 번역한 후 실행합니다. 이 부분은 인터프리터 언어의 특성을 가지고 있다고 볼 수 있습니다. 따라서 자바는 하이브리드 언어라는 이름으로 불립니다.
- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  - 자바 프로그램을 실행하면 JVM 은 운영체제로부터 메모리를 할당받습니다. 그 후 자바 컴파일러가 자바 소스코드를 자바 바이트코드로 컴파일합니다. JVM의 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area 에 올립니다. Runtime Data Area에 로딩된 바이트 코드는 실행엔진을 통해 명령어 단위로 해석되고 실행됩니다.
- **JVM의 구조에 대해 설명해주세요.**

  <details>
  <summary>JVM 구조</summary>

  - JVM

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/2b417674-9775-408c-8bc5-25b877639daf)

  - Class Loader

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/cbdce3f2-d119-4548-98ff-1b4bd55137cb)

  - Execution Engine

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/ff138ec5-9227-4af8-8f03-aa79ade86093)

  - 출처 : [JVM 내부 구조 & 메모리 영역 💯 총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8)

  </details>

  - JVM의 구조는 크게 **Class Loader, Runtime Data Area, Execution Engine** 영역으로 나눌 수 있습니다.
  - **클래스 로더**
    - 3가지 단계 (로딩, 링킹, 초기화) 으로 구성됩니다.
    - 우선 자바 컴파일러를 통해서 .class 확장자를 가진 클래스 파일은 각 디렉토리에 흩어져 있고, 기본적인 라이브러리들의 클래스 파일은 $JAVA_HOME 내부 경로에 존재합니다. 각각의 클래스 파일을 찾아서 JVM의 메모리 영역인 Runtime Data Areas 에 로드해주는 역할을 합니다. 두번째로는 로드된 클래스를 검증하고 기본값으로 초기화하는 링킹 과정도 합니다. 세번째로는 static field 의 값들을 정의한 값으로 초기화하는 과정도 합니다.
  - **실행 엔진**
    - 실행엔진에는 **JIT Compiler, Garbage Collector** 이 있습니다.
    - 실행 엔진은 **인터프리터**와 **JIT 컴파일러**를 이용해서 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다. 일반적으로는 바이트 코드를 한 줄마다 읽어서 해석하고 바로 실행하는 인터프리터 방식으로 작동합니다. 하지만 매번 번역하는 작업은 번거롭기 때문에 특정 조건을 만족하면 JIT 컴파일러를 사용해 바이트코드전체를 컴파일하여 네이티브 코드로 변환합니다. 이후 같은 바이트코드에 대해서는 사전에 컴파일된 것을 캐시처럼 갖고 있다가 다시 사용할 수 있게끔 해줍니다.
    - 실행 엔진에는 **Garbace Collector(GC)** 도 포합되어 있습니다. GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시켜주는 장치입니다. GC가 동작하는 대상은, **Heap 영역** 내의 객체 중 참조되지 않는 데이터 입니다. GC가 주로 heap 영역을 대상으로 하는 이유는, heap 영역은 모두 공유되기 때문에, 하나의 메소드가 종료되어도 heap 영역의 데이터를 함부로 삭제할 수 없기 때문입니다. GC가 실행될때는 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지되게 하는 Stop-the-World 현상이 발생합니다. 따라서 모든 쓰레드가 정지되기 때문에 성능이 저하됩니다. 그래서 적절한 빈도의 GC가 실행되도록 하는 점이 중요합니다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  <details>
  <summary>JVM Runtime Data Area </summary>

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/9c92bb22-9439-4bf5-a40d-a332af92ed0a)

  - [JVM에 관하여 - Part 3, Run-Time Data Area](https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/)
  - [Chapter 2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-2.html#jvms-2.5.4)
  </details>

  - JVM Runtime Data Area 에는 크게 **Method Area, Heap, JVM Stacks, Native Method Stacks, PC registers** 가 존재합니다. Method Area, Heap 영역은 모든 쓰레드가 공유하고, JVM Stacks, PC registers ,Native Method Stacks 는 쓰레드 별로 생성되고 해당 쓰레드가 종료될 때 소멸됩니다.
  - **Method Area**(=Static Area)는 JVM 이 시작될 때 생성되고, 바이트코드를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간입니다. JVM이 동작하고 클래스가 로드될 때 적재되서 프로그램이 종료될 때까지 저장됩니다. 여기에는 run-time constant pool, 필드와 메서드 데이터, 메서드와 생성자를 위한 코드(클래스와 인스턴스 초기화에서 사용되는 스페셜 메서드) 를 저장합니다. 자바 파일의 필드 부분에서 선언된 전역변수와 정적 멤버 변수들의 데이터를 저장합니다.
  - **Heap** 영역은 메서드 영역과 함께 모든 쓰레드들이 공유하며, JVM 이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용되는 영역입니다. new 연산자로 생성되는 객체와 인스턴스 변수, 배열 타입 등 참조형 타입이 저장됩니다.
  - **Stack** 영역은 기본 자료형을 생성할 때 저장하는 공간으로, 임시적으로 사용되는 변수나 정보들이 저장되는 영역입니다. 메서드 호출 시마다 각각의 스택 프레임이 생성되고, 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장합니다.
  - **Native Method Stacks**는 JVM stack 과 비슷한 데이터들을 저장하지만, 자바가 아닌 다른 언어로 작성된 네이티브 메서드를 실행할 때 사용됩니다.
  - 스레드는 각자의 메서드를 실행합니다. 이때, 스레드 별로 동시에 실행하는 환경이 보장되어야 하므로 최근에 실행 중인 JVM에서는 명령어 주소값을 저장할 공간이 필요합니다. 이 부분을 **PC registers**가 관리하고 추적합니다. 즉, PC register 는 JVM에서 사용되었던 명령어 주소 값을 저장합니다.

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**

  - 힙 영역은 모든 스레드들이 공유하는 반면, 스택 영역은 스레드마다 각자의 메모리 공간을 가지고 있습니다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**

  ```java
  count = 0
  count ++
  ```

  - 위의 코드에서 동시성 문제가 생길 수 있습니다. 두 개의 스레드에서 `count++` 를 하면 기대값은 2가 되야 하는데, 결과값이 1인 경우가 생길 수 있습니다. `count++` 의 경우 실제로 CPU는 count read, count increase, count write 3가지 단계의 연산으로 나누어 실행합니다. 이 3가지 단계의 연산을 두 개의 스레드에서 실행할 때, 하나의 스레드가 read 단계까지만 수행한 후 OS 스케쥴러가 다른 스레드에 CPU 를 할당시켜줄 수 있습니다. 그러면 다른 스레드도 read 단계에서 count 값이 0이라고 인식합니다. 다시 원래 스레드가 CPU 를 할당받아서 increase, write 까지 수행해도 다른 스레드에서는 이미 0 을 read 했기 때문에 값이 똑같이 1로 write 됩니다. 이것은 `count++` 연산이 원자성이 보장되지 않아서 생기는 문제입니다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**

  - 우선, 참조형 타입의 경우에는 스택 영역에 실제 객체의 주소가 저장되고, 스택 영역에는 그 객체의 주소값이 저장됩니다. 따라서 메서드가 종료되면 스택이 사라지면서 그 객체의 주소값을 저장하고 있는 참조변수가 사라지게 됩니다. 그렇게 아무런 참조변수가 힙 영역의 객체를 참조하고 있지 않으면, GC가 객체를 Unreachable 로 판단하여 제거합니다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**

  - 자바에서 stack 영역은 스레드마다 하나씩 존재하며, 스레드 내에서 실행되는 각 메서드 호출 정보에 대한 정보를 저장하는 공간입니다. 메서드가 호출될 때마다 해당 메서드를 위한 프레임이 스택에 추가(push) 되며, 메서드가 종료될 때 해당 프레임은 스택에서 제거(pop) 됩니다. 프레임 내에는 지역 변수, 매개 변수, 연산 중간 결과와 같은 값들이 저장되어 있습니다.
  - Heap 영역은 JVM 전체에서 공유되는 메모리 영역으로, 모든 스레드가 접근할 수 있습니다. 자바에서 동적으로 할당된 객체와 배열이 이 영역에 할당됩니다. 즉, `new` 키워드를 사용해서 생성된 모든 객체와 배열이 여기에 저장됩니다. Heap 영역은 가비지 컬렉터(Garbage Collector)에 의해 관리되며, 더 이상 참조되지 않는 객체들은 가비지 컬렉터에 의해 자동으로 메모리에서 제거됩니다.

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**

  - 기본 데이터 타입 변수(ex. int, float, boolean..) 는 실제 값이 스택 영역에 저장되고, 참조 타입 변수는 실제 객체의 값은 heap 영역에 저장되지만 해당 객체를 가리키는 참조 값(메모리 주소)는 스택 프레임 내 저장됩니다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**

  - new 에 의해 생성된 객체는 힙 영역에 저장되고, 스택 영역에는 생성된 객체의 참조인 p 가 저장됩니다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 객체가 메서드 종료 후에도 메모리에 남아 있는 이유는 객체의 생명주기가 해당 객체를 생성한 메서드의 생명주기와 독립적이기 때문입니다. 객체는 힙 영역에 저장되며, 이 영역은 JVM 내 다른 스레드에서도 접근할 수 있습니다. 객체가 어떤 메서드에서 생성되었더라도, 다른 메서드에서 이 객체에 대한 참조를 가지고 있다면, 그 객체는 여전히 유효하고 접근 가능합니다. 따라서 객체의 생명은 참조가 있는 동안 계속되며, 모든 참조가 사라지고 나서야 GC에 의해 메모리에서 제거될 수 있습니다.
- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 스태틱 영역(=Method 영역) 과 힙 영역 모두 모든 쓰레드가 공유한다는 공통점이 있습니다.
  - 프로그래머가 만든 Class 는 스태틱 영역에 저장되고, `new` 연산을 통해 생성한 객체는 힙 영역에 생성됩니다. 객체의 생성시에 할당된 힙영역 메모리는 GC를 통해 수시로 관리합니다. 하지만 스태틱 영역에 할당된 메모리는 GC의 영역 밖에 존재합니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?

`final` 키워드는 자바에서 변수, 메서드, 클래스에 대한 변경을 제한하기 위해 사용됩니다.

- 변수에 `final` 이 사용되는 경우

  - `final` 변수는 멀티스레드 환경에서 공유될 때 추가적인 동기화 없이도 작업이 안전하다는 것을 보장합니다. (thread-safe)
  - 원시 변수에 `final` 로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됩니다. (`final int x = 1`)
  - 객체 변수에 `final` 로 선언하면, 그 변수에 다른 참조 값을 지정할 수 없습니다. 단, 객체 자체가 immutable 하다는 의미는 아니며, 객체의 속성은 변경 가능합니다.

  ```java
      public void test_final_reference_variables() {
        final Pet pet = new Pet();
        // pet = new Pet(); //다른 객체로 변경할수 없음

        pet.setWeight(3); //객체 필드는 변경할 수 있음

    }
  ```

- 메서드에 `final` 이 사용되는 경우
  - `final` 로 선언된 메서드는 하위 클래스에서 오버라이드할 수 없습니다. 따라서 `final` 로 선언된 메서드는 컴파일 시점에 어느 클래스가 실행될 지 알 수 있으며, 정적 디스패치가 가능하여, 동적 디스패치보다 실행 시간을 단축할 수 있습니다.
- 클래스에 `final` 이 사용되는 경우

  - `final` 로 선언된 클래스는 상속될 수 없습니다. 이는 컴파일러가 클래스의 모든 메서드를 자동으로 `final` 메서드로 취급할 수 있게 합니다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - `final`로 선언된 변수가 컴파일 시점에 리터럴 값으로 초기화된 경우, 컴파일러는 이 변수를 상수로 취급하고 해당 변수가 사용된 모든 위치를 실제 값으로 대체할 수 있습니다.
  - `final` 로 선언된 메서드는 오버라이딩이 불가능하기 때문에, 컴파일러와 JVM은 이 메서드를 호출하는 부분에 메서드의 본문을 직접 삽입하는 최적화(인라이닝)을 수행할 수 있습니다. 이는 메서드 호출에 대한 오버헤드를 줄이고 성능을 향상시킵니다.
  - `final` 로 선언된 클래스는 상속될 수 없으므로, 컴파일러는 `final` 클래스의 모든 메서드들을 자동으로 `final` 취급합니다. 따라서 클래스와 관련된 다이나믹 디스패치가 필요 없으므로 컴파일러는 더 효율적인 코드를 생성할 수 있습니다.

### 3. 변수는 어떤 것인가요?

변수란 단 하나의 값을 저장할 수 있는 메모리 공간입니다. 변수를 사용하려면 변수를 선언하고, 변수를 초기화해야 합니다. 변수의 자료형에는 크게 기본형(primitive), 참조형(reference) 두 가지로 나눌 수 있는데, 기본형 변수는 실제 값을 저장하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소를 값으로 갖습니다. 기본형 변수에는 논리형(boolean), 문자형(char), 정수형(byte,short,int,long), 실수형(float,double) 이 있습니다.

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**

  - 참조형 변수에서 참조값은 각 스레드 내의 스택 영역에 저장되고, 실제 객체 데이터는 JVM내 스레드들이 공유하는 힙 영역에 저장됩니다. 이때 객체 데이터의 크기는 매우 클 수 도 있고, 데이터의 크기는 변화할 수 있습니다. 따라서 메모리 주소만 저장함으로써 메모리 사용을 더욱 효율적으로 관리할 수 있습니다. 또한 참조를 통해 여러 변수가 동일한 객체를 가리킬 수 있으므로, 데이터가 중복되어 저장되는 것을 방지합니다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**

  - 기본형 변수는 고정된 크기를 가지며, 이들의 처리는 참조형 변수에 비해 상대적으로 단순하고 빠릅니다. 스택 영역은 메서드 호출과 함께 실행 컨텍스트를 저장하는 공간입니다. 여기에 저장된 변수는 메서드 실행 동안 빠르게 접근되고, 메서드 종료 시 함께 소멸되므로 메모리 관리가 효율적입니다. 또한 기본형 변수는 고정된 크기를 사용하므로, 스택에 할당하기 적합합니다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변수와 상수는 데이터를 저장하는 컨테이너라는 공통점이 있지만, 그 값을 변경할 수 있는지 여부에 따라 차이가 있습니다. 프로그램 실행 중에 변수에 저장된 값은 변경될 수 있습니다. 변수는 프로그램이 실행되는 동안 정보를 저장하고, 수정하며, 참조하기 위해 사용됩니다. 반면 상수는 한 번 값이 할당되면 프로그램 실행 도중 그 값이 변경될 수 없는 메모리 공간입니다. 자바에서는 `final` 키워드를 통해 상수를 선언합니다.

### 4. 부동소수점이 무엇인가요?

컴퓨터에서 실수를 표현하는 방식으로는 대표적으로는 고정 소수점 방식(fixed-point number representation) 과 부동 소수점 방식(floating-point number representation) 으로 나눌 수 있습니다. 자바의 float 타입을 기준으로, 실수 메모리는 총 32비트를 할당받습니다. 부동소수점은 정수부, 소수부가 16비트로 나누어져 있는 고정 소수점 방식과 달리 메모리를 가수부(23bit)와 지수부(8bit)로 나눕니다. 가수부에는 실제 실수 데이터 비트들이 들어가고, 지수부에는 소수점의 위치를 가리키는 제곱승이 들어갑니다. 따라서 부동소수점을 사용하면 더 큰 범위의 값을 표현할 수 있습니다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**

  - 아닙니다. 0.625 같이 이진수 소수점으로 딱 떨어지는 수 도 있지만, 0.1과 같이 무한 반복되는 이진수 실수는 아무리 큰 수를 저장하는 부동소수점 방식이라 하더라도 무한대를 저장할 수 없으므로 메모리 한계까지 소수점을 집어넣고 어느 부분에서 끊어 반올림을 해주어야 합니다. 이를 무한 소수라고 합니다. 이러한 무한 소수 때문에 부정확한 실수의 계산결과가 생기게 됩니다.

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**

  - 자바에서는 2가지 방법을 제공하는데, 첫번째는 int,long 정수형 타입으로 치환하고 사용하는 방법과 두번째는 BigDecimal 클래스를 이용하는 방법입니다.
  - 첫번째 방법은 예를 들어 23.25에 100을 곱해서 2535로 정수로 치환해서 계산하고 다시 100으로 나누는 방법입니다.
  - 첫번째 방법으로는 소수의 크기가 18자리를 초과하는 경우 int,long 타입으로 표현할 수 없기에 BigDecimal 클래스를 사용해야 합니다. BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 아주 작은 수와 아주 큰 수의 연산에 대해 무한한 정밀도를 보장합니다.

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**

  - BigDecimal 은 int 의 배열로 저장합니다. 큰 숫자를 배열에 나눠 담는 형식으로 구현됩니다. BigDecimal 은 임의 정밀도 정수형인 unscaled value 와 소수점 오른쪽의 자릿수를 나타내는 32bit 정수인 scale 로 구성됩니다. 만약 3.14 의 경우 unscaled value 는 314, scale 은 2가 됩니다.

  ```java
  package java.math;

  public class BigDecimal extends Number implements Comparable<BigDecimal> {

      private final BigInteger intVal; // = unscaled value
      private final int scale; // 소수점 오른쪽의 자릿수
      private transient int precision; // 총 자릿수
      private final transient long intCompact;
      ...
  ```

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?

- `==` 연산자

  - **스택 메모리에 있는 값을 비교**하는 연산자입니다.
  - 기본형 타입의 경우, 스택 메모리에 값 자체가 저장되기 때문에 데이터의 값을 비교합니다.반면 참조형 타입의 경우 객체의 주소가 스택 메모리에 저장되어 있기 때문에, 주소값을 비교합니다. 따라서 객체의 값이 같더라도 주소값이 다르다면 false 를 반환합니다.

- `equals()` 메서드

  - `equals()` 메서드는 객체의 내용 자체를 비교하는 데 사용됩니다. `Object` 클래스에서 상속받은 `equals()` 메서드는 기본적으로 `==` 연산자와 동일하게 객체의 참조를 비교합니다. 하지만, 대부분의 클래스 (String, Integer 등 자바 표준 클래스) 에서는 `equals()` 메서드를 오버라이드하여 객체의 내용을 비교하도록 구현합니다. 이렇게 오버라이드된 `equals()` 메서드는 두 객체의 실제 데이터 값을 비교하여, 내용이 같다면 `true`를 반환합니다.

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**

  ```java
  // Object equals() 메서드
  public boolean equals(Object obj) {
    return (this == obj);
  }
  ```

  - Object 의 `equals()` 메서드는 두 참조가 실제로 같은 객체를 가리키는지 확인합니다. 이 기본 구현은 참조 동등성만 고려하기 때문에, 객체의 논리적 동등성(logical equality)를 비교하려면 `equals()` 메서드를 오버라이드 해야 합니다.
  - 예를 들어 **String** 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 문자열의 내용이 같은지 비교합니다. 첫번째로 현재 객체(`this`) 와 비교 대상 객체(`anObject`) 의 참조를 비교해서 같은 메모리 주소를 가리키면 `true` 를 반환합니다. 만약 메모리 주소가 같지 않더라도, 논리적 동등성을 확인합니다. 우선 `anObject instanceof String aString` 부분은 `anObject` 가 `String` 타입인지 확인하고, 현재 문자열과 비교 대상 문자열의 내부 표현 방식(`coder`)이 같은지 비교합니다. 마지막으로 `StringLatin1.equals(value, aString.value)` 를 통해 두 문자열이 같은 값을 가지고 있는지 확인합니다.

    ```java
    // String equals() 메서드
    public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
    ```

  - Integer 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 Integer 객체 내부 값이 같은지 비교합니다.

    ```java
    // Integer equals() 메서드
    public boolean equals(Object obj) {
      if (obj instanceof Integer) {
          return value == ((Integer)obj).intValue();
      }
      return false;
    }
    ```

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```

  - 위의 코드는 `false` 를 반환합니다. `==` 연산자는 두 객체의 참조를 비교합니다. 즉, 두 객체가 메모리 상에서 같은 위치를 가리키는지 확인합니다. 코드에서 `a` 와 `b` 는 `Integer` 클래스의 인스턴스이며, `new Integer(3)` 을 통해 각각 생성됩니다. `new` 키워드를 사용하면 자바 힙 메모리에 새로운 객체가 할당됩니다. 따라서 `a`,`b` 는 내용은 같지만 실제로는 메모리 상의 서로 다른 위치에 있는 별개의 객체입니다.

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

  - `hashCode()` 메서드는 객체의 주소값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환합니다. 그렇기 때문에 서로 다른 두 객체는 같은 해시 코드를 가질 수 없게 됩니다.

- **`hashCode()` 의 용도는 무엇인가요?**

  - `hashCode()` 의 용도는 하나의 객체에 대한 해시코드 값을 만드는 것입니다. 해시코드는 Hash table, Hash map 등 해시를 사용하는 자료구조에서 해시 함수 의 용도로 쓰입니다. Object 클래스 내에 정의된 `hashCode()`는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 `hashCode()` 를 호출한 결과가 서로 유일한 훌륭한 방법입니다.

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**

  - 자바에는 `equals()` 의 결과가 `true` 인 두 객체의 해시코드는 반드시 같아야 한다는 규칙이 있습니다. 따라서 `equals()` 를 오버라이딩 했다면, `hashCode()` 도 오버라이딩 해야 합니다. 두 메서드를 같이 재정의하지 않을 시, hash 값을 이용하는 Collection Framework (HashSet, HashMap, HashTable) 을 사용할 때 문제가 생깁니다.
  - 조금 더 자세히 설명하자면, `hashCode()` 와 `equals()` 의 동작 순서를 알아야 합니다. 우선 컬렉션에 데이터를 추가할 때, 그 데이터의 `hashCode()` 리턴 값을 컬렉션이 가지고 있는지 비교합니다. 만일 해시코드가 같다면 그제서야 다음으로 `equals()` 메서드의 리턴값을 비교하게 되고, true 이면 논리적으로 같은 객체라고 판단합니다. 만약 `equals()`만 재정의하고 `hashCode()`를 재정의하지 않는다면, HashSet 또는 HashMap 등 해싱을 구현한 컬렉션 클래스에는 `equals()` 호출 결과가 true 지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장하는 문제가 생깁니다.

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**

  - `equals()` 를 재정의 할 때, 다음의 순서대로 재정의합니다.
  - 순서1. 두 객체가 동일한 참조 값을 가지는지 확인합니다. 둘 다 동일한 참조 값을 가지는 경우 데이터도 동일하므로 true 를 반환하도록 합니다.
  - 순서2. 매개변수로 전달받는 객체가 null 이거나 두 객체가 동일한 타입이 아니라면, false 를 반환하도록 합니다.
  - 순서3. 매개변수로 전달받은 매개변수를 현재 클래스 타입으로 반환합니다.
  - 순서4. 모든 필드의 값을 비교합니다. 기본 타입이라면 `==` 연산자를 사용하고 참조 타입인 경우 Objects 클래스의 `equals()` 메서드를 사용할 수 있습니다.

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - 자바에서는 똑같이 해시코드를 반환해주는 또 다른 메서드인 `identityHashCode()` 가 있습니다. 만약 `hashCode()` 를 오버라이딩 해서 쓰는데, 오버라이딩 하기 전의 원조 기능이 필요할때 사용 하는 메서드입니다.

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

다형성은 객체 지향 프로그래밍의 핵심 원리 중 하나로, "많은 형태를 가질 수 있는 능력"을 의미합니다. 다형성은 같은 인터페이스나 메서드 호출이지만, 다양한 객체애 대해 다른 방식으로 작동할 수 있게 해줍니다. 자바에서 다형성은 주로 상속과 인터페이스를 통해 구현됩니다.

다형성은 두 가지 주요 형태로 나타납니다.

- 컴파일 타임 다형성(정적 다형성) : 메서드 오버로딩을 통해 구현됩니다. 이는 같은 클래스 내에서 메서드 이름이 같지만, 매개변수의 타입이나 개수가 다른 여러 메서드를 정의할 수 있게 해줍니다. 컴파일러는 메서드를 호출때 제공된 인자에 기반하여 어떤 메서드를 사용할 지 결정합니다.
- 런타임 다형성(동적 다형성) : 상속과 인터페이스를 활용한 메서드 오버라이딩을 통해 구현됩니다. 상위 클래스 또는 인터페이스 타입의 참조 벼수가 다양한 하위 클래스의 객체를 참조할 수 있으며, 실행 시간에 어떤 클래스의 메서드를 호출할지 결정됩니다. 이것은 같은 인터페이스를 구현하거나 같은 클래스를 상속받은 다양한 객체들이 있을 때, 이들 객체를 동일한 방식으로 처리할 수 있게 해줍니다.

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- 인터페이스

  - 내부의 모든 메서드는 `public abstract` 로 정의 (`default` 메서드 제외) 하고, 내부의 모든 필드는 `public static final` 상수 입니다. 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다. 이때 `implements` 키워드를 사용하여 구현합니다.
  - 인터페이스 자체를 확장시키고 싶다면, `extends` 를 통해 인터페이스를 상속하면 됩니다. 클래스와 달리 인터페이스 끼리의 상속은 다중 상속이 가능합니다. 왜냐하면 메서드 구현부가 없으므로 충돌 가능성이 없기 때문입니다.

  ```java
  interface TV {
    int MAX_VOLUME = 10; // public static final 생략 가능
    int MIN_VOLUME = 0;

    default boolean turnOn(boolean state){ // default method
      state = true;
      return state
    }
    default boolean turnOff(boolean state){
      state = false
      return state
    }
    void changeVolume(int volume); // public abstract 생략 가능
    void changeChannel(int channel);
  }
  ```

- 추상클래스

  - 추상클래스는 하나 이상의 추상 메서드를 포함한 클래스입니다. 추상 클래스는 인스턴스 변수, 인스턴스 메서드를 가질 수 있습니다. 추상 클래스를 상속 받는 하위 클래스에서 추상 메서드를 구현해야 합니다. 추상클래스는 `new` 생성자를 통해 인스턴스 객체로 직접 만들 수 없고, 반드시 어느 자식의 클래스에 상속시키고 자식 클래스를 인스턴스화 해서 사용해야 합니다.

  ```java
  abstract class Pet {
    abstract public void walk(); // 추상 메소드 -> 상속받은 자식 클래스가 구현
    abstract public void eat(); // 추상 메소드 -> 상속받은 자식 클래스가 구현

    public int health; // 인스턴스 필드
    public void run() {  // 인스턴스 메소드
      System.out.println("run run");
    }
  }
  ```

- 인터페이스 vs 추상클래스

  - 추상 클래스는 상속 받아서 기능을 확장시키는 데 목적을 둡니다. 반면에 인터페이스는 구현 객체의 동일한 실행 기능을 보장하기 위한 목적입니다. 키워드에서도 의미를 볼 수 있는데, 추상클래스는 `extends` 키워드를 사용하여, 자신의 기능들을 하위로 확장시키는 것입니다. 반면에 인터페이스는 `implements` 키워드를 사용하여, 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 구현하는 것으로 볼 수 있습니다.
  - 또 다른 관점에서는 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화 시켜놓은 것으로 상속 관계를 타고 올라갔을 때, 같은 부모 클래스를 상속하며 _부모 클래스가 가진 기능들을 구현해야 하는 경우_ 에 사용합니다. 반면 인터페이스는 상속 관계를 타고 올라갔을 때 다른 부모 클래스를 상속하더라도 *같은 기능이 필요한 경우* 에 사용됩니다.

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**

  - 다중 상속을 하게 되면, 두 상위 클래스가 동일한 시그니처(메서드의 접근 제어자, 리턴 타입, 메서드 명, 매개변수가 모두 동일함)를 가진 동일한 메서드를 가지고 있을 때 하위 클래스가 어느 쪽의 메서드를 상속받을지 명확하지 않은 문제가 발생할 수 있습니다. 하지만 인터페이스는 위의 문제를 피해갈 수 있습니다. 왜냐하면 메서드가 정의되지 않았기 때문입니다. 부모 중 아무거나 상속받아도, 어차피 해당 메서드는 구현되지 않아 자식 클래스에서 새롭게 정의해야 합니다.

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**

  - 만약 5개의 클래스 (class A, ... Class E) 가 인터페이스 A 를 구현하고 있다고 해봅시다. 이때, 요구사항이 추가되어 인터페이스A에 특정 추상 메서드 methodA 를 추가해야 한다고 생각해봅시다. 그렇다면 인터페이스 원칙에 의해 class A, ... Class E 에 모두 methodA 를 구현해야 합니다. 이것은 '소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다' 는 개방 폐쇄 원칙(OCP) 에 어긋나는 경우입니다. 따라서 Java8 에서부터 인터페이스에도 구현된 몸통이 있는 `default` 메서드가 생겼습니다.
  - `default method` 는 인터페이스에 있는 구현 메서드를 의미합니다. 기존의 추상 메서드와 다른 점은 메서드 앞에 `default` 예약어를 붙이고, 구현부 `{}` 가 있어야 한다는 점입니다. `default method` 를 사용하면, 추가 변경을 막을 수 있어 OCP 를 지키는 코드를 작성할 수 있습니다. `default method` 는 인터페이스를 구현한 클래스에서 코드를 구현할 의무는 없지만, 원한다면 재정의할 수 있습니다.
  - 보통 인터페이스를 구현한 이후, 수정과정에서 인터페이스 모든 구현체에게 광역으로 함수를 만들어주고 싶을 때 사용합니다.

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**

  - 첫번째 방법으로는 명시적인 메서드 오버라이드가 있습니다. 클래스A 는 두 인터페이스의 `default` 메서드를 명시적으로 오버라이드(재정의)하고, 자신의 구현을 제공해야 합니다. 두번째로는, 만약 클래스가 두 인터페이스의 `default` 메서드 중 하나를 선택하여 사용하려면, 해당 메서드를 오버라이드하고, 선택된 인터페이스의 `default` 메서드를 명시적으로 호출해야 합니다.

  ```java
  // classA 가 InterfaceA , InterfaceB 의 default method(someMethod()) 를 오버라이드
  @Override
  public void someMethod() {
    InterfaceA.super.someMethod(); // InterfaceA 의 default method 를 사용한다고 명시적으로 호출
  }
  ```

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

- **상속(Inheritance)**
  - 상속은 한 클래스가 다른 클래스의 속성과 메서드를 확장(상속)할 수 있도록 하는 메커니즘입니다. 상속을 통해, 하위 클래스(subclass)는 상위 클래스(superclass)의 모든 public과 protected 멤버를 재사용할 수 있습니다. 하지만 상위 클래스의 구현이 하위 클래스에게 노출되는 상속은 캡슐화를 깨뜨립니다. 만약 상위 클래스에서 메서드 이름이나 매개변수가 변화하면 하위 클래스 전체에서 변경해주어야 합니다. 이처럼 상속은 하위 클래스가 상위 클래스에 강하게 결합, 의존하게 되고 강한 결합, 의존은 변화에 유연하게 대처하기 어려워집니다.
  - 따라서 상속은 확장을 고려하고 설계한 확실한 'is-a' 관계일 때 사용해야 합니다.
- **조합(Composition)**
  - 조합은 기존 클래스가 새로운 클래스의 구성요소로 쓰이는 방식입니다. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조한다. 조합을 사용하면, 한 클래스가 다른 클래스의 기능을 '가지고 있는(has-a)' 관계를 형성합니다. 새로운 클래스에서는 기존 클래스의 메서드를 호출하는 방식으로 동작합니다. 이 때문에 캡슐화를 깨뜨리지 않고, 기존의 클래스가 변화에도 새로운 클래스에는 미치는 영향이 적습니다.

### 9. 리플렉션에 대해 설명해 주세요.

리플렉션이란 프로그램 실행 중에, 사용자와 운영체제 및 기타 프로그램과 상호작용 하면서 클래스와 인터페이스를 검사하고 조작할 수 있는 기능입니다. 자바 소스코드를 실행하면, 자바 컴파일러가 소스코드를 자바 바이트코드로 변환하고, 이것을 클래스 로더가 JVM Runtime Data Area 에 올려주게 됩니다. 그 중 Method Area 에 클래스에 대한 메타 데이터를 저장합니다. 따라서 리플렉션은 Method Area 에 있는 메타데이터를 가지고 런타임에 클래스를 검사하고 조작합니다.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

  - 리플렉션을 사용하면, 런타임에 클래스의 private 필드나 메서드에 접근하고, 수정할 수 있습니다. 이러한 능력은 캡슐화와 정보 은닉 원칙을 위반할 수 있습니다. 또한 private 메서드를 호출하거나 변경함으로써 객체의 안정성을 해칠 수 있습니다.
  - 보안 문제 방지를 위해서는 여러 가지 방법이 있습니다. 첫번째로는 접근 제어입니다. `java.lang.reflect.AccessibleObject`의 `setAccessible` 메서드를 사용하여 private 멤버에 대한 접근을 가능하게 할 수 있습니다. 하지만, 보안 관리자(Security Manager)를 설정하고, 적절한 권한을 부여하지 않으면 이러한 접근을 제한할 수 있습니다.

- **리플렉션을 언제 활용할 수 있을까요?**
  - 많은 라이브러리와 프레임워크에서 리플렉션을 활용합니다. 라이브러리와 프레임워크에서는 사용자가 컴파일하기 전까지 객체의 타입을 알 수 없습니다. 이러한 문제를 동적으로 해결하기 위해 리플렉션을 사용합니다. Spring 의 의존성 주입, Hibernate 의 ORM 매핑, JUnit 의 어노테이션 기반 테스트 실행 등에서 활용됩니다.

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

풀(Pool) 이란 자원을 사용하는 시점에서 메모리에 올리고, 사용을 완료한 이후 메모리에서 해제하는 대신 _이미 사용할 준비가 된 자원을 메모리 위에 일정량 미리 생성해둔 자원의 집합_ 입니다. 자원이 필요한 경우 새로 자원을 생성하는 대신 풀에서 꺼내 사용하고, 사용이 완료된 경우 자원을 해제하는 대신 풀에 다시 반환하는 형태로 사용합니다. 자원을 미리 생성해두면 자원이 필요할 때 자원의 생성, 파괴 비용을 절약할 수 있습니다. 즉, 오버헤드를 줄일 수 있습니다.

쓰레드 풀이란 쓰레드를 미리 생성하고, 작업 요청이 발생할 때 마다 미리 생성된 쓰레드로 해당 작업을 처리하는 방식을 의미합니다. 이때, 작업이 끝난 쓰레드는 종료되지 않으며 다음 작업 요청이 들어올 때까지 대기합니다. 쓰레드 풀을 사용하면 이런 쓰레드 폭증으로 인한 애플리케이션 성능 저하를 방지할 수 있습니다. 쓰레드를 제한된 개수로 생성한 뒤, 들어오는 작업을 작업 큐(task queue)에 채워 넣은뒤 쓰레드 별로 할당하여 작업을 처리합니다.

### 13. Error 와 Exception 의 차이가 무엇인가요?

<details>
<summary>Error, Exception</summary>

![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/a53b853e-5009-40a1-9c16-a051acd15f14)

</details>

자바에서 Error 와 Exception 은 모두 Throwable 클래스를 상속받지만, 사용 목적과 처리 방법에서 중요한 차이가 있습니다.

**오류(Error**)는 시스템이 종료되어야 할 수준의 상황과 같이 프로그래머가 수습할 수 없는 심각한 문제를 의미합니다. 프로그래머가 미리 예측하여 방지할 수 없습니다. 오류의 예시로는 `OutOfMemoryError`, `StackOverflowError`, `NoClassDefFoundError` 등이 있습니다. 이들은 시스템 레벨의 예외로, 자원 부족 또는 구성 오류와 같은 심각한 상황을 나타냅니다.

반면 **예외(Exception)**는 프로그래머가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생합니다. 오류와 달리 개발자가 예외를 캐치하여 어플리케이션 중단을 방지할 수 있기 때문에 상황에 맞는 예외처리를 해야 합니다. 예외에는 체크 예외(Checked Exception) 과 언체크 예외(Unchecked Exception) 이 있습니다.

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

  - Checked Exception
    - 컴파일 시점에 체크되는 예외로, `Exception` 클래스를 상속받고, `RuntimeException` 클래스는 상속받지 않는 예외들입니다. `IOException`, `SQLException` 등이 있습니다. Checked Exception은 반드시 try-catch 블록으로 처리하거나, 메서드 시그니처에 throws 키워드를 사용하여 선언해야 합니다.
  - Unchecked Exception

    - 런타임에 발생하는 예외로, `RuntimeException` 클래스와 그 하위 클래스들입니다. 프로그램 로직 상 잘못된 부분을 뜻합니다. 예를 들어, , 배열의 인덱스가 범위를 벗어날 때 발생하는 `IndexOutOfBoundsException` , 0으로 나눌 때 발생하는 `ArithmeticException`, 객체의 참조가 null일때 발생하는 `NullPointerException`, 은 메서드에 전달된 인자가 부적절할 때 발생하는 `IllegalArgumentException` 등이 있습니다. Unchecked Exception은 선택적으로 처리할 수 있으며, 프로그램의 버그나 잘못된 사용으로 인해 주로 발생합니다.

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

  - JVM 에서 힙 영역의 메모리를 다 사용했을 때 발생합니다. `new` 키워드로 객체를 생성하면 그 객체는 우선 힙 영역에 저장됩니다. 만약 힙 영역이 꽉 찼다면, Garbace collector 가 작동합니다. 만약 GC가 작동했음에도 불구하고 힙 영역에 새로운 객체를 할당할 공간이 없으면 `OutOfMemoryError`가 나타납니다.
  - 구체적인 상황으로는, 만약 `static` 키워드로 배열을 만들고, 그 안에 참조형 변수를 저장하면 객체는 힙 영역에 저장됩니다. 하지만 정적 영역에 저장된 배열은 jvm 이 종료되기 전까지 메모리가 해제되지 않습니다. 또한 정적 영역은 GC의 대상이 아니기 때문에 jvm 이 종료되기 전까지 힙 영역에 저장된 객체들은 참조하는 변수가 있는 reachable 객체로 간주됩니다. 따라서 GC 는 이 객체들을 제거할 수 없습니다. 만약 코드를 잘못 작성한다면 이러한 문제들이 생길 수 있습니다. 따라서 스태틱 영역에 넣을 때는 메모리 릭이 발생하지 않도록 프로그래머가 관리를 해야 합니다.
  - 또 다른 상황으로는 힙 영역이 모든 요청을 처리하기에는 공간이 작아서 발생할 수 있습니다. 만약 5만개의 요청을 처리하는 어플리케이션에 맞는 힙 영역을 할당했는데, 그보다 많은 요청이 들어오면 힙 영역이 부족해져서 `OutOfMemoryError`가 발생할 수 있습니다. 이러한 경우에는 jvm 을 종료하고 시작할 때 힙 영역의 사이즈를 늘려서 할당시켜줄 수 있습니다.

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

  - 스레드 내에서 메소드가 시작될 때, 필요한 스택 영역을 할당받습니다. 만약 메소드 안에서 다시 메소드를 실행하면, 또 스택 영역을 할당 받습니다. 이런 식으로 계속 메소드 내에서 메소드를 호출하면 스택 영역이 꽉 차게 되어 `StackOverflowError` 가 발생합니다. 흔히 재귀함수에서 `StackOverflowError` 가 발생합니다.

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**
  - 자바는 과거에는 목적 자체가 서버를 위한 언어는 아니었습니다. 원래는 냉장고, 텔레비전 등 다양한 상황에서 사용하기 위해 만든 언어였습니다. 그러다 보니 예외가 발생했을 때 처리를 강제 해서 메인 함수가 종료되는 문제를 막고 안정성을 높이는 것이 중요했습니다. 따라서 체크 예외에서는 try-catch 를 강제했습니다. 하지만 현재 자바는 서버를 위한 언어로 가장 많이 쓰입니다. 이때도 프레임워크와 같이 사용합니다. 따라서 요즘은 체크 예외를 많이 쓰지 않고 다 런타임 예외로 처리를 하는 추세입니다.
